use mod base.*;
use mod base.init.*;
use mod base.list.*;
use mod base.format.FormatPart;

use mod message;

testList := cons[int](5, cons[int](2, nil[int]));

a := head[int](testList);
b := head[int](nil[int]);

!bind[](
	bind[](
		return[](10),
		a => return[](a * 5)),
	a => printTwice[int](a));

!bind[](
	bind[](
		return[]("Hello, World!"),
		a => return[]("Hello, World!")),
	a => printTwice[](a));


!printTwice[](false);
!printTwice[](true);

printTwice := (val: $T) -> Init[Unit]
	=> init.bind[](printLn(ToString[T].toString(val)),
		a => printLn(ToString[T].toString(val)));

!printLn(match Maybe[int].Some(3) {
	Maybe[int].Some(2)  => "two";
	Maybe[int].Some($a) => "something else";
	Maybe[int].None     => "nothing";
});

!message.msg[](message.onStart, a =>
	message.bind[](message.return[](2),
		b => message.io[](io.printLn(ToString[int].toString(b)))));


foo := true;
bar := 2;
baz := "hello";

!printLn(f"${baz}, world! ${foo}, ${bar}+2 = ${bar+2}");

# !msg(message.onStart, do {
# 	a := Pass(2);
# });

# !onStart >> _ => Pass(2) >>= a => io(printInt(a));

fmt := cons[FormatPart](
	FormatPart.Lit("Foo Hello, "),
	cons[FormatPart](
		FormatPart.Expr(() => ToString[String].toString("World")),
			cons[FormatPart](
				FormatPart.Lit("!"), nil[FormatPart])));
!printLn(format.format(fmt));
