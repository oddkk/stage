# Comments
# Anything on a line after #, except inside strings.

# Types
# Default: int, string, type
# Composit types:
# * Tuples (int, int)
# * Named tuples (a: int, r: int)
# * Arrays (int[4])

# Type definitions
Color :: (r: int, g: int, b: int);

# Value instansiation
foo := 3;
boo: int = 5;

white: Color = (255, 255, 255);
red         := (255, 0, 0);

assert typeof(white) == Color;

# Without @type, this would be an instance of a tuple of three types,
# with the value (int, int, int).
assert typeof(red) == type((int, int, int));

list := [4, 5, 6];
assert typeof(list) == type(int[3]);

Bool :: Enum {
	false,
	true,
};

# Channel declaration
test_channel := Channel(int);

assert typeof(test_channel) == Channel(int);

# Devices
RGBLedCan :: Device {
	cnl := Channel(int);
};

assert typeof(RGBLedCan) == type;

can := RGBLedCan;

# Traits / Type class?
# Like interfaces

Type :: Class {
};

In($T) :: Class {
	# op->(lhs: Channel(T), rhs: self) -> self;
	# default_in() -> Channel(T);
};

Out($T) :: Class {
	# op->(lhs: self, rhs: Channel(T)) -> T;
	# default_out() -> Channel(T);
};

# Docstrings?

# """
# Returns 0.

# @param a: Does nothing.
# @returns: Zero.
# """
asdf(a: int) -> int = 0;

# Attributes?

RGBLedCan2 :: Device {
	[Input, Default]
	in := Channel(int);

	[Input]
	other_in := Channel(int);

	[Output]
	out := Channel(int);

	[Output, Default]
	other_out := Channel(int);
};

Foo(a: int) :: Device {
	out := Channel(int);
};

# foos := [x: (0..10); Foo(x)];

dmx[6..] <- foos[..].out;
