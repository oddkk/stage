Bool :: Enum {false, true}
use Bool.*;

Maby(T: Type) :: Enum {Some(T), None}
use Maby.*;

# TODO: Ifs
# op->(lhs: Maby($T), rhs: ($T) -> Maby($U)) -> Maby($U)
# 	= if Some(val) = lhs { rhs(val) } else { None };

ColorRGB :: (r: int, g: int, b: int);
# DmxValue :: int{0..255};

# Type(T: Type) :: @builtin("base", "type_constructor");
# Channel(T: int) :: @builtin("channel_constructor");
# Channel(T: ($T, ...)) -> (Channel($T), ...) = @builtin("channel", "channel_");
# Channel(T: $T[$N]) -> Channel($T)[$N] = @builtin();

ButtonColor :: (int, int);
FakeLaunchpad :: Device {
	button_down  := Channel(int[8][8]);
	button_color := Channel(ButtonColor[8][8]);
};

FakeDmxUniverse :: Device {
	in := Channel(uint8[512]);
};

# typeof(a: $T) -> Type = @builtin;

# op->(rhs: (Channel($T), ...), lhs: ($T, ...) -> $U) -> Channel($U) = @builtin;

foo  := Channel(float);
asdf := Channel(float);

# asdf <- sin(foo) + 1;
asdf <- \foo sin(foo) + 1 <- foo;

# default_channels!(
# 		in:  Maby(($self) -> Channel($T)) = None,
# 		out: Maby(($self) -> Channel($U)) = None) {
# 	if Some(fun) = in {
# 		op<-(lhs: $self, rhs: Channel($T)) -> Channel($T) {
# 			fun(lhs) <- rhs;
# 		}
# 	}
#
# 	if Some(fun) = out {
# 		op<-(lhs: Channel($U), rhs: $self) -> Channel($U) {
# 			lhs <- fun(rhs);
# 		}
# 	}
# }

# [def_in](cnl: Channel($T), self: type = typeof(@owner)) {
# 	op<-(lhs: $self, rhs: Channel($T)) -> Channel($T) {
# 		fun(lhs) <- rhs;
# 	}
# }
#
# [def_out](cnl: Channel($T), self: type = typeof(@owner)) {
# 	op<-(lhs: Channel($U), rhs: $self) -> Channel($U) {
# 		lhs <- fun(rhs);
# 	}
# }

MessageToggle :: Device {
	msg := Message(None);
	# @def_out
	out := Channel(Bool);

	# default_channels!(
	# 	out = \a a.out,
	# );
}

MessageKeepLast(T: type) :: Device {
	msg := Message(T);
	out := Channel(T);

	# default_channels!(
	# 	out = \a a.out,
	# );

	# Something to make out the last value received from msg.
}

UserOverride(T: type, U: type) :: Device {
	in  := Channel(T);
	out := Channel(U);

	set    := MessageKeepLast(T);
	reset  := Message;
	active := Toggle;
	active.in <- reset;

	out <- Mux(active.out, [
		(true,  set.out),
		(false, in),
	]);

	# default_channels!(
	# 	in  = \a a.in,
	# 	out = \a a.out,
	# );
};

# op[](lhs: $T[$N], rhs: int) -> $T = @builtin array;
# op[](lhs: $T[$N], rhs: Range) -> Iterator($T) = @builtin array;

namespace fixture {
	LedRGBCan :: Device {
		color  := Channel(ColorRGB);
		output := Channel(uint8[6]);

		output <- UserOverride <- input;

		# default_channels!(
		# 	in  = \a a.color,
		# 	out = \a a.output,
		# );
	};
}

# # mux or match?
# Mux(val: Channel($T), in: ($T, Channel($U))[$N]) -> Channel($U) = @builtin mux;

# # Same as mux, but indexes on array id
# ArrayMux(val: Channel($T), in: Channel($U)[$N]) -> Channel($U) = @builtin arraymux;

Bypass(func: Channel($T), T: Type) :: Device {
	bypass := Channel(Bool);

	in  := Channel($T);
	out := Channel($T);

	out <- Mux(bypass, [
		(true,  in),
		(false, func),
	]);
}

universe := FakeDmxUniverse;

led1 := fixture.LedRGBCan;
universe.in[0..] <- led1;

led2 := fixture.LedRGBCan;
universe.in[6..] <- led2;




# function declaration
square(a: int) -> int = a * a;

# function overload
square(a: float) -> int = a * a;

# types
# Color: Type = (r: int, g: int, b: int);
# Color = (r: int, g: int, b: int);
# Type Color = (r: int, g: int, b: int);
# Color = Type((r: int, g: int, b: int));

Color :: (r: int, g: int, b: int);

namespace novation.launchpad {
}

# fist_set(a: $T[$N], idx: int) -> Maby(int)
# 	= if a == 1 {
# 		Some(idx)
# 	} else {
# 		first_set(a[1..], idx + 1)
# 	};

# fist_set(a: $T[0], idx: int) -> Maby(int)
# 	= None;

# fist_set(a: $T[0]) -> Maby(int)
# 	= fist_set(a, 0);

Radio(N: int) :: Device {
	buttons := Channel(Bool[N]);
	value   := Channel(int);

	value <- \buttons first_set(buttons) <- buttons;

	# default_channels!(
	# 	in  = \a a.buttons,
	# 	out = \a a.value,
	# );
};

RadioSelect(N: int, T: type) :: Device {
	# [def_in]
	values  := Channel(T[N]);

	# [def_out]
	out     := Channel(T);

	buttons := Channel(Bool[N]);

	selected := Channel(int);
	selected <- Radio(N) <- buttons;

	out <- ArrayMux(selected, values);
};
