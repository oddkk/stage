# mod channel;
mod message;
mod sql;

op+ := base.op+;
op- := base.op-;
op* := base.op*;
op/ := base.op/;
int := base.int;
Unit := base.Unit;
String := base.String;
Type := base.Type;
id := base.id;
compose := base.compose;

List := [T: Type] Variant {
	Cons Struct { head: T; tail: Unit; },
	Nil
};

TypeList := List[Type];

Init := [T: Type] Struct {
	unsafePerformInit: () -> T;
};

return := (val: $T) -> Init[T]
	=> Init[T] {
		unsafePerformInit = () -> T
			=> val;
	};

join := (a: Init[Init[$T]]) -> Init[T]
	=> Init[T] {
		unsafePerformInit = () -> T
			=> a.unsafePerformInit().unsafePerformInit();
	};

fmap := (f: ($T) -> $U, a: Init[T]) -> Init[U]
	=> Init[U] {
		unsafePerformInit = () -> U
			=> f(a.unsafePerformInit());
	};

bind := (a: Init[$T], f: (T) -> Init[$U]) -> Init[U]
	=> Init[U] {
		unsafePerformInit = () -> U
			=> join[](fmap[](f, a));
	};

# someinittest: Init[int] = join(return(return(2)));
# asdf: int =! someinittest;

# init: Init[Unit] = bind(return(2), (a: int) -> Init[Unit]
# 	=> return(base.print(a)));

# !bind(return(2), (a: int) -> Init[Unit]
# 	=> return(base.print(a)));

composeTest := base.compose[](
	(a: int) -> int => a + 2,
	(a: int) -> int => a * 2);

typeof := (a: $T) -> Type => T;
asdfasdfasdfasdf := (a: typeof[](2)) -> int => a + 2;

# Monad := Struct { a: int; set: int; };
# Some  := (val: int) -> Monad => Monad { a = val; set = 1; }
# None  := () -> Monad { a = 0; set = 0; }
# 
# bind := (a: Monad, (int) -> Monad) -> Monad
# 	=> 

# cnl: channel.Channel(int) = channel.Const(2);
# 
# prnt := channel.Print { in=cnl; };

# prnt := message.Print(message.Map(
# 	message.onStart, () -> int => 2));

# conStr := "host=localhost port=5432 dbname=test user=test";
# db: Connection = sql.postgresql.connect(conStr);
# DBConnectionHandle := int;
# 
# _dbConnect := (conStr: String) -> DBConnectionHandle
# 	@nativeImpure("db_connect");
# 
# Connection := Struct {
# 	connectionString: String;
# 	handle: DBConnectionHandle = _dbConnect(connectionString);
# };
# connect := (connectionString: String) -> Connection
# 	=> Connection { connectionString = connectionString; };
# 
# query: sql.Query(int) = sql"
# 	select foo from my_table
# 	where 
# ".query(int);
# 
# stmt: sql.Statement(Unit, int) = sql"
# 	insert into my_table (foo) values ($foo)
# ".statement();

# message.onStart >>= db.exec(query);

# Monad := [T: Type] Struct { val: T; };
# 
# bind := (v: Monad[$T], f: (T) -> $U) -> Monad[U]
# 	=> Monad[U] { val = 2; };
# unit := (v: $T) -> Monad[T]
# 	=> Monad[T] { val = v; };

# a := bind(unit(2), (a: int) -> int => a * 2);

# testQuery: sql.SQL[int] = sql.sql("
# 	select * from foo where a = ?
# ");
#
# testQuery2 := sql.sql[int]("
# 	select * from foo where a = ?
# ");

TestType := [T: Type] Struct {
	a: T;
};

TT2 := TestType[int];

prnt := message.Print(
	message.Map[](
		message.Map[](message.onStart, (a: Unit) -> int => composeTest(500)),
		(a: int) -> int => a * 2));

prnt2 := message.PrintStr(
	message.Map[](message.onStart, (a: Unit) -> String => "Hello, World!"));

# con := sql.postgresql.connect("");

# asdfasdfasdf := message.msgId(message.onStart);

func_test := (base.Type, int) -> int;

id_test := id[](2);

Color := Struct {
	r: int;
	g: int;
	b: int;
};

col1 := Color { r=5; g=6; b=7; };

addFive := (a: int) -> int => a + 5;

b := addFive(1);
j := addFive(9);

c: Color;
c.r = 1;
c.g = 2;
c.b = 3;

col2 := Color { r=8; g=9; b=10; };

# TODO: Fix
# Foo := Struct {
# 	foo: int ~= 6;
# 	bar: int ~= 2;
# 	baz: int  = 3;
# 	sum: int  = foo + bar + baz;
#
# 	bar = 5;
# };

# foobar: Foo;
# foobar.foo = 3;

# b := addFive(int);
