# Bool :: Enum { true, false }
# Foo :: (asdf: Bool, fdsa: (foo: int, bar: str));
# Foo :: (Bool, (int, str));
# Foo :: (int, (int, str));

# foo : Foo = (Bool.false, (3, "asdf"));

# asdf = foo.fdsa.bar;

two = 2;
four = 2 + 2;
some_number := 2 * 3 + 5 - 6 + print(four());

foo := print(some_number);
bar := print("asdf");

d = print(four());
dd := d();

# d = print(3);
# dd := d();

f = print("fasdf");
ff := f();

# print <- some_number;

# some_string = "foo";
# some_string2 = "foo" + "bar";

# op*(lhs: int, rhs: int) -> int;

use channel;

printer := Print("asdf");
# printer <- Node(\a a * 2) <- Node(3);
printer <- Node(3);


assert square(5) == 25;
# assert square(5) == 26;
# assert (\a a)(2) == 2;


asdf := square(5) * add(3, square(4));

square(x: int) = x * x;
add(x: int, y: int) = x + y;





double(x: int) -> int = 2 * x;
# double(x: (int, Bool)) = 2 * x;

# test = print(square(4) + square(6));

# assert square(2) == 4;
# assert some_number == 5;

# fib(n: int) =
# 	if n > 1 then
# 		fib(n - 1) + fib(n - 2)
# 	else
# 		1;

# Option(T: type) :: Enum { Some(T), None };

# bind(in: Option($T), fun: ($T) -> Option($U)) =
# 	match in {
# 		  Some(t) => fun(t),
# 		  None    => None
# 	};
