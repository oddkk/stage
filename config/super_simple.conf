version 0.1.0;

device_type fake_launchpad {
	output button_down: int[8][8];
	input  button_color: midi.novation.button_color[8][8];

	output right_button_down: int[8];
	input  right_button_color: midi.novation.button_color[8];


	output top_button_down: int[8];
	input  top_button_color: midi.novation.button_color[8];
}


device_type fake_dmx {
	input default in: int[512];
}

device basic.lighting.dmx universe;
device midi.novation.launchpad lp;

# device fake_dmx universe;
# device fake_launchpad lp;

#type color_rgbwau = int[6];
type color_rgbwau = (r: int, g: int, b: int, w: int, a: int, u: int);

namespace color {
	namespace rgbwau {
		device basic.constant off    (value = [  0,   0,   0,   0,   0,   0]);
		device basic.constant red    (value = [255,   0,   0,   0,   0,   0]);
		device basic.constant green  (value = [  0, 255,   0,   0,   0,   0]);
		device basic.constant blue   (value = [  0,   0, 255,   0,   0,   0]);
		device basic.constant amber  (value = [  0,   0,   0, 255,   0,   0]);
		device basic.constant white  (value = [  0,   0,   0,   0, 255,   0]);
		device basic.constant uv     (value = [  0,   0,   0,   0,   0, 255]);
	}
}

namespace martin {
	device_type thrill_par_64_led {
		output default dmx: int[6];
		input color: color_rgbwau;

		dmx <- color;
	}
}

device_type radio_select (N: int, T: type, Color: type) {
	input          values:   $T[$N];
	input  default in:       int[$N];
	output         in_color: $Color[$N];
	output default out:      $T;

	device basic.radio radio  (N=N);
	device basic.mux   select (N=N, T=T);
	device basic.demux col    (N=N, T=Color);

	radio.radio <- in;
	select.select <- radio;
	select.in <- values;
	out <- select;

	col.select <- radio;
	col.in <- button_on_color;
	col.off_value <- button_off_color;
	in_color <- col;
}

# RadioSelect(N: int, T: type, Color: type) = Device {
# 	values   := Channel(T[N]);
# 	in       := Channel(int[N]);
# 	in_color := Channel(Color[N]);
# 	out      := Channel(T);

# 	radio    := basic.radio(N);
# 	select   := basic.mux(N, T);
# 	col      := basic.demux(N, Color);

# 	radio.in <- in;
# 	select.select <- radio;
# 	select.in <- values;
# 	out <- select;

# 	col.select <- radio;
# 	col.in <- button_on_color;
# 	col.off_value <- button_off_color;
# 	in_color <- col
# }

# rs := RadioSelect(7, int, color.rgbwau);
# RadioSelectRgbwau := (N: int, T: type) = RadioSelect(N, T, color.rgbwau);

# # Binds the output from rhs to the input of lhs
# op<-(lhs: Channel($T), rhs: Channel($T)) -> Channel($T) = @builtin channel identity bind

# cast(a: $T) -> Channel($T) = @builtin create constant channel
# cast(a: (a: $T) -> $U) -> Channel($U) = @builtin create channel

# # cast(a: $T -> $U) -> Channel($U) = Device {
# # 	for ((name, t) in $T) {
# # 		$name = Channel($t);

# # 	}

# # 	out := Channel($U);
# # 	out <- 
# # }

# # op :: (u -> t) -> Channel t -> channel u;
# op<-(lsh: (a: $U) -> $T, rhs: Channel($T)) -> Channel($U) = @builtin;

# op<-(lsh: (a: $S, b: $T) -> $U, rhs: (Channel($S), Channel($T))) -> Channel($U) = @builtin;
# op<-(lsh: (Channel($S)...) -> $U, rhs: (Channel($S)...)) -> Channel($U) = @builtin;

# asdf = Channel(float);
# foo  = Channel(float);

# sin(a: float) = ...;

# foo  <- 1.0;
# asdf <- ((a: float) -> Channel(float) = sin(a)) <- foo;

# # op<-(lhs: Channel($U), rhs: (a: $T) -> Channel($U)) -> Channel($T) = @builtin channel bind




device basic.constant button_on_color  (value = [3, 0]);# (red = 3, green = 0));
device basic.constant button_off_color (value = [0, 1]);# (red = 0, green = 1));


type launchpad_grid = int[8][8];
type launchpad_color_grid = midi.novation.button_color[8][8];
device_type paged_launchpad {
	output default pages: launchpad_grid[8];
	input  default pages_color: launchpad_color_grid[8];

	device basic.radio radio (N = 8);

	radio.radio <- lp.right_button_down;

	device basic.mux(N = 8, T = launchpad_color_grid) {
		select <- radio;
		in <- pages_color;
		lp.button_color <- out;
	}

	device basic.demux(N = 8, T = launchpad_grid) {
		select <- radio;
		in <- lp.button_down;
		pages <- out;
	}

	device basic.demux radio_color_out(T = midi.novation.button_color, N = 8);
	radio_color_out.select <- radio;
	radio_color_out.in <- button_on_color;
	radio_color_out.off_value <- button_off_color;
	lp.right_button_color <- radio_color_out;
}

device paged_launchpad lp_paged;




device martin.thrill_par_64_led led1 { universe.in[0..6]  <- dmx; }
device martin.thrill_par_64_led led2 { universe.in[6..12] <- dmx; }


# device radio_select color_select(N = 7, T = color_rgbwau, Color = midi.novation.button_color);

# color_select.values[0] <- color.rgbwau.off;
# color_select.values[1] <- color.rgbwau.red;
# color_select.values[2] <- color.rgbwau.green;
# color_select.values[3] <- color.rgbwau.blue;
# color_select.values[4] <- color.rgbwau.amber;
# color_select.values[5] <- color.rgbwau.white;
# color_select.values[6] <- color.rgbwau.uv;

# color_select.in[..] <- lp_paged.pages[0][0][0..7];
# lp_paged.pages_color[0][0][0..7] <- color_select.in_color[..];

# # device basic.ease (T = color_rgbwau) { led1.color <- out; in <- color_select; }
# led1.color <- color_select;



# device radio_select color_select2(N = 7, T = color_rgbwau, Color = midi.novation.button_color);

# color_select2.values[0] <- color.rgbwau.off;
# color_select2.values[1] <- color.rgbwau.red;
# color_select2.values[2] <- color.rgbwau.green;
# color_select2.values[3] <- color.rgbwau.blue;
# color_select2.values[4] <- color.rgbwau.amber;
# color_select2.values[5] <- color.rgbwau.white;
# color_select2.values[6] <- color.rgbwau.uv;

# color_select2.in[..] <- lp_paged.pages[0][1][0..7];
# lp_paged.pages_color[0][1][0..7] <- color_select2.in_color[..];

# # device basic.ease (T = color_rgbwau) { led2.color <- out; in <- color_select2; }
# led2.color <- color_select2;

# device basic.blink (T = midi.novation.button_color) {
# 	device basic.constant(value = (red = 3, green = 0)) {
# 		on_value <- out;
# 	}

# 	device basic.constant(value = 50) {
# 		duration <- out;
# 	}

# 	reset <- lp.top_button_down[7];

# 	device basic.tap_tempo {
# 		trigger <- lp.top_button_down[7];
# 		period <- out;

# 		device basic.print tempo_print (T = int) {
# 			in <- out;
# 		}
# 	}

# 	lp.top_button_color[7] <- out;
# }

device_type intensity_select {
	input  default in:       int[8];
	output         in_color: midi.novation.button_color[8];
	output default out:      int;

	device radio_select r(N=8, T=int, Color=midi.novation.button_color);

	device basic.constant c0 (value = 0);
	device basic.constant c1 (value = 37);
	device basic.constant c2 (value = 74);
	device basic.constant c3 (value = 111);
	device basic.constant c4 (value = 148);
	device basic.constant c5 (value = 185);
	device basic.constant c6 (value = 222);
	device basic.constant c7 (value = 255);

	r.values[0] <- c0;
	r.values[1] <- c1;
	r.values[2] <- c2;
	r.values[3] <- c3;
	r.values[4] <- c4;
	r.values[5] <- c5;
	r.values[6] <- c6;
	r.values[7] <- c7;

	r.in <- in;
	in_color <- r.in_color;
	out <- r.out;
}

device_type color_sel (page: int) {
	output default color: color_rgbwau;

	device intensity_select red   {
		in[0..8] <- lp_paged.pages[page][0..8][0];
		lp_paged.pages_color[page][0..8][0] <- in_color[0..8];
		color.r <- out;
	}
	device intensity_select green {
		in[0..8] <- lp_paged.pages[page][0..8][1];
		lp_paged.pages_color[page][0..8][1] <- in_color[0..8];
		color.g <- out;
	}
	device intensity_select blue  {
		in[0..8] <- lp_paged.pages[page][0..8][2];
		lp_paged.pages_color[page][0..8][2] <- in_color[0..8];
		color.b <- out;
	}
	device intensity_select white {
		in[0..8] <- lp_paged.pages[page][0..8][3];
		lp_paged.pages_color[page][0..8][3] <- in_color[0..8];
		color.w <- out;
	}
	device intensity_select amber {
		in[0..8] <- lp_paged.pages[page][0..8][4];
		lp_paged.pages_color[page][0..8][4] <- in_color[0..8];
		color.a <- out;
	}
	device intensity_select uv    {
		in[0..8] <- lp_paged.pages[page][0..8][5];
		lp_paged.pages_color[page][0..8][5] <- in_color[0..8];
		color.u <- out;
	}
}

device color_sel led1_sel (page = 1) { led1.color <- color; }
device color_sel led2_sel (page = 2) { led2.color <- color; }

# # Implement functions
# foo(a: int) -> int = 2 * a;
# asdf <- foo(2);

# # Implement arithmetic operations (+-*/, etc), such that it can be overridden
# # eg:
# op+(a: int, b: int) -> int = @builtin addint

# # "Polymorphic" types, eg. for channels ( Channel($T) )
# a := Channel(int);
# a <- 3;

# # Devices should not have bodies?
# asdf(foo: int) = device {
# 	asdf := channel(int);
# 	asdf <- foo;
# }
# foo := asdf(2);

# # Implement more complex types? eg. sound, images or video?
# foo := channel(media.image);

# # Detach device and channel even more? Make channels only have a "user
# # data" pointer, that the device fills with itself.

# # Channels are monads/functors?
# fmap($A -> $B, channel($A)) -> channel($B) = @builtin channel_fmap;
# ident($A, channel($B)) -> channel($A) = @builtin channel_ident;

# # Ifs and conditionals
