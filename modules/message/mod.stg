int := base.int;
Unit := base.Unit;

# Print  := (val: int) -> Message[Unit];
# Delay  := (val: $T, time: TimeDelta) -> Message[T];
# Map    := (val: $T, fun: (T) -> $U) -> Message[U];

Endpoint := (func: ($T) -> Unit) -> ((Message[T]) -> Unit) @nativeImpure("msg_endpoint");

Print    := Endpoint[]((val: int) -> Unit @nativeImpure("msg_print_int_callback"));
PrintStr := Endpoint[]((val: base.String) -> Unit @nativeImpure("msg_print_string_callback"));

Map := (in: Message[$T], f: (T) -> $U) -> Message[U] @nativeImpure("msg_map");
# Fitler := (in: Message[$T], f: (T) -> Bool) -> Message[T] @nativeImpure("msg_filter");

# bind := (in: Message[$T], f: (T) -> Message[$U]) -> Message[$U]
# 	=> ;

# Message := [T: Type] Struct { msgId: int; };
# return := (val: $T) -> Message[T] => ;
# Map := (in: Message[$T], f: (T) -> Message[$U]) -> Message[U] @nativeImpure("msg_map");
