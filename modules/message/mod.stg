Msg := @native("Msg");
onStart := @native("onStart");

map := (a: Msg[$T], fn: (T) -> $U) -> Msg[U]
	=> ((a: Msg[T], fn: (T) -> U, typeIn: Type, typeOut: Type) -> Msg[U]
		@native("msg_functor_map"))(a, fn, T, U);

# TODO: Bool
# filter := (a: Msg[$T], fn: (T) -> Bool) -> Msg[T]
# 	=> ((a: Msg[T], fn: (T) -> U, type: Type) -> Msg[T]
# 		@native("msg_functor_filter"))(a, fn, T);

# TODO: IO
# io := (a: Msg[$T], fn: (T) -> IO[$U]) -> Init[Msg[U]]
# 	=> ((a: Msg[T], fn: (T) -> IO[U], typeIn: Type, typeOut: Type) -> Init[Msg[U]]
# 		@native("msg_functor_io"))(a, fn, T, U);

# print := (a: Msg[$T]) -> Init[Unit]
# 	=> io(a, io.print);

# !print(map(!onStart, (a: Unit) => 2));
# main := bind(
# 	onStart,
# 	(onStart: Msg[Unit])
# 		=> print(map(onStart, a => 2))
# );
